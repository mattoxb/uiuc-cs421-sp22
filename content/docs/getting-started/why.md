---
title: "Why Should I Take This Course?"
linktitle: Why Take This?
date: 2021-06-25
draft: false
menu: getting-started
type: book
weight: 2
---


{{< callout warning >}}
We are preparing the site for the Fall 2022 semester.  Feel free to look around, but note that not all the pages
are up yet.
{{< /callout >}}

There are many benefits to study programming languages.  Here are some that might be convincing
to you.

## Gain the ability to implement a language.

Before taking this course you are most likely a *consumer* of programming
languages.  You may have opinions about which ones you like best, but your
options are restricted to languages that already exist.  After this course, you
will be able to design and implement a language for yourself.  Maybe you're
thinking, "Why would I need to do that?"  One reason this happens is that the
developers of a software product decide they want to enable their users to write
scripts to control it.  There are languages like Lua you could use, but they might
not be a good fit.

## Document your language and understand language documentation 

A good part of this course covers an area called *semantics*, or the meaning
of languages.  Being able to write a formal specification of your language means
that if multiple teams decide to implement it, their implementations will all do
the same thing.  (At least, there's a chance that could happen!)  Being able to read
a formal specification of a language means you will understand precisely how a
feature works.

You can also use formal semantics of languages to do things like verify the
correctness of a program in certain situations.  (The [halting problem](https://en.wikipedia.org/wiki/Halting_problem) means
we'll can't hope to do it in all cases.)

## See the variety of languages specialized for certain tasks

Most of the languages you will have learned to this point are general purpose
languages.  And most of them are imperative (command based) languages with objects
and classes as a major component.  In this class you will learn other language paradigms
such as functional (Haskell and Scheme), logic (Prolog), and stack-based (Forth).
Functional languages allow very reliable and very concise programs.  Prolog can solve
your type-inferencer MP in about 15 minutes, instead of the week we are going to give
you to implement it in Haskell.  Languages like Forth are well suited for embedded
systems.  Scheme has a language construct that allows you to *program the programming language* itself.  

You can live a long and happy programmer's life only knowing Python or Javascript,
but then you would never even be aware of some of the other options you have.

