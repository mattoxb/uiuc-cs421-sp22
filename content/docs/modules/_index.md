---
title: Learning Modules
linktitle: 
date: 2021-06-25
draft: false
icon: code
icon_pack: fas
type: book
weight: 2
---

This content of this course is categorized into *Learning Modules*.
Here are the different Learning Modules in which you will gain proficiency.

<hr/>

## Haskell and Functional Programming

**Why this is important:**  Functional programming is one of the major paradigms
of programming languages, and one of the oldest.  Functional programs tend to be
easier to debug, to reason about mathematically, and to ``get right'' the first time.
They are becoming increasingly common in industry, and most modern languages now
include major concepts from the functional programming paradigm.

Relevant to this course, functional programming languages happen to be well-suited
for implementing programming languages.

### Learning Modules

We give numbers to the learning modules to facilitate grading and reporting.  They roughly
correspond to the order in which you will see them in class, but we don't guarantee that.
They're kind of like the order numbers you get at [Portillo's](https://portillos.com).

- [1. Recursion]({{< relref "01-recursion" >}})
- [2. Algebraic Data Types]({{< relref "02-algebraic-data-types" >}})
- [3. Higher Order Functions]({{< relref "03-higher-order-functions" >}})
- [11. Type Classes and Monads]({{< relref "11-type-classes-and-monads" >}})

<hr/>

## Interpreters
**Why this is important:**  This is a programming language class.  You should expect to learn
how to implement a programming language, right?

### Learning Modules
- [4. Interpreters (Expressions)]({{< relref "04-interpreters-expressions" >}})
- [5. Interpreters (Functions)]({{< relref "05-interpreters-functions" >}})

<hr/>

## Mathematical Foundations

**Why this is important:**  In order to reason about programs and programming
languages well, we need certain mathematical structures with which to model
them.  Mastery of this will enable you to read documentation, know the abilities
and limits of programming languages, prove properties (such as correctness)
about your programs, and document your languages so other people can understand
and implement them.

### Learning Modules

- [6. Lambda Calculus]({{< relref "06-lambda-calculus" >}})
- [7. Evaluation Semantics (Big Step and Small Step semantics)]({{< relref "07-evaluation-semantics" >}})
- [8. Typing Semantics]({{< relref "08-typing-semantics" >}})
- [9. Hoare Logic]({{< relref "09-hoare-logic" >}})
- [10. Continuations]({{< relref "10-continuations" >}})
- [16. Unification]({{< relref "16-unification" >}})

<hr/>

## Grammars and Parsing

**Why this is important:** The semantics tell you how a language works when it's
in the computer; grammars and parsing explain how to get the text you type to
become the data structure the computer can manipulate.

### Learning Modules
- [12. Grammars]({{< relref "12-grammars" >}})
- [13. Regular Languages]({{< relref "13-regular-languages" >}})
- [14. LL Parsing]({{< relref "14-ll-parsing" >}})
- [15. LR Parsing]({{< relref "15-lr-parsing" >}})

We will also cover Combinator Parsing here, but it is an extra topic.

<hr/>

## Pragmatics
**Why this is important:** In this section we talk about different design decisions you could make that
affect the kind of language you will have.

### Learning Modules

- [17. State and Objects]({{< relref "17-state-and-objects" >}})
- [18. Prolog]({{< relref "18-prolog" >}})
- [19. Variables and Parameters]({{< relref "19-variables" >}})
- [20. Macros and Metaprogramming]({{< relref "20-metaprogramming" >}})
